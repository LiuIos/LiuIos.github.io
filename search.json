[{"title":"Xcode 15 的Library \"iconv2.4.0\"not found问题解决办法","date":"2024-02-21T07:10:02.000Z","url":"/2024/02/21/Xcode-15-%E7%9A%84Library-iconv2-4-0not-found%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","tags":[["iOS","/tags/iOS/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"]],"content":"1.首先在项目的targets 的build phases 移除iconv.2.4.0 2.然后在link binary witch libraries 添加 libiconv.tbd 和 libiconv.2.tbd 3.在项目的targets 的Other Linker Flags 添加-ld64"},{"title":"react-native修改第三方包","date":"2023-12-08T03:17:24.192Z","url":"/2023/12/08/react-native%E4%BF%AE%E6%94%B9%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85/","tags":[["react-native","/tags/react-native/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"]],"content":"使用第三方包的时候，经常需要修改内部源码来解决 bug 和实现效果，然而每次 yarn、npm install 之后，修改的代码又会被覆盖，让人抓狂，下面介绍一个好用的方法 👇 使用工具：patch-package 用法修改 package.json,添加 &quot;postinstall&quot;: &quot;patch-package&quot; 执行 yarn add patch-package postinstall-postinstall -D 修改第三方库后， 应用补丁 "},{"title":"译-从零扩展到数百万用户","date":"2023-05-15T07:42:33.000Z","url":"/2023/05/15/%E8%AF%91-%E4%BB%8E%E9%9B%B6%E6%89%A9%E5%B1%95%E5%88%B0%E6%95%B0%E7%99%BE%E4%B8%87%E7%94%A8%E6%88%B7/","tags":[["-书籍 -系统设计面试","/tags/%E4%B9%A6%E7%B1%8D-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95/"]],"categories":[[" ",""]],"content":"设计一个支持数百万用户的系统具有挑战性，这是一个需要不断完善和无尽改进的旅程。在本章中，我们构建了一个支持单个用户的系统，并逐渐将其扩展为数百万用户提供服务。阅读本章后，您将掌握一些技术，这些技术将帮助您破解系统设计面试问题。 单服务器设置千里之行始于足下，构建一个复杂的系统也是这样。从很简单的开始，所有程序都在单个服务器上运行。如图1-1所示，单服务器设置中，所有的内容都在一台服务器上运行，web app, 数据库，缓存等。 要了解此设置，调查请求流和流量来源是有帮助的。让我们先看看请求流程（图1-2）。 1.用户通过域名访问网站，例如api.mysite.com。通常，域名系统（DNS）是由第三方提供的付费服务，而不是由我们的服务器托管。 2.互联网协议（IP）地址返回到浏览器或移动应用程序。在示例中，返回IP地址15.125.23.214。 3.一旦获得IP地址，超文本传输协议（HTTP）[1]请求将直接发送到您的Web服务器。 4.Web服务器返回HTML页面或JSON响应进行渲染。 接下来，让我们检查一下流量来源。您的Web服务器的流量来自两个来源：Web应用程序和移动应用程序。 Web应用程序：它使用服务器端语言（Java、Python等）的组合来处理业务逻辑、存储等，以及客户端语言（HTML和JavaScript）进行演示。 移动应用程序：HTTP协议是移动应用程序和Web服务器之间的通信协议。由于其简单性，JavaScript对象表示法（JSON）是常用的API响应格式来传输数据。JSON格式的API响应示例如下所示： GET /users/12 – Retrieve user object for id = 12 数据库(Database)随着用户群的增长，一台服务器是不够的，我们需要多台服务器：一台用于网络/移动流量，另一台用于数据库（图1-3）。分离网络/移动流量（网络层）和数据库（数据层）服务器允许它们独立扩展。 使用哪些数据库？可以选择关系型数据库和非关系型数据库，具体区别如下： 关系型数据库：又称RDBMS(relational database management system)， 最主要有MySQL, Oracle database, PostgreSQL等。这些数据将数据存储在表和行里面，可以在不同的数据中进行join操作 非关系型数据库：又称NoSQL 数据库，有CouchDB,Neo4j, Cassandra, HBase, Amazon DynamoDB[2]等，可以分为key-value 型、图型、列型和文档性， 这些数据库通常不支持join操作。 大多数情况下，关系型数据是适用的，但是如果有以下特殊的情况，可以考虑NoSQL: 用户需要极低的延时 数据是非结构化的，不需要任何关系型数据 只有序列化和反序列化的数据（JSON, XML, YAML, etc） 需要存储极大规模数据 垂直扩展和水平扩展垂直扩展，称为“向上扩展”，指的是使用性能更强大的服务器（CPU、RAM等）。水平扩展（称为“横向扩展”），使用更多的服务器来进行扩展。 流量很低的时候，使用垂直扩展,好处是非常简单，但是会受到限制： 不可能在一台机器上无限添加CPU和内存 一台服务器，不能做到故障容错和冗余，如果一台服务器宕机，那么整个网站直接全部崩溃 基于以上垂直扩展以上限制，水平扩展更适合大型应用， 在之前的设计中，用户直接连接到web服务器。如果web服务器处于离线状态，用户将无法访问该网站。在另一种情况下，如果许多用户同时访问web服务器，当访问量达到web服务器的负载限制，会出现响应较慢或无法连接到服务器的情况，而负载均衡器可以有效解决这些问题。 负载均衡器负载均衡器在负载平衡集中定义的Web服务器之间均匀分配传入流量。图1-4显示了负载均衡器的工作原理。 如图1-4所示，用户直接连接到负载均衡器的公共IP。通过此设置，客户端无法再直接访问网络服务器。为了提高安全性，私有IP用于服务器之间的通信。专用IP是只能在同一网络中的服务器之间访问的IP地址；然而，它无法通过互联网访问。负载均衡器通过专用IP与Web服务器通信。 在图1-4中，在添加负载均衡器和第二个Web服务器后，我们成功解决了故障转移问题，并提高了Web层的可用性。详情如下： 如果服务器1离线，所有流量将路由到服务器2。这样可以防止网站崩溃。我们还将向服务器池中添加一个新的健康web服务器，以平衡负载 如果网站流量快速增长，而两台服务器不足以处理流量，负载平衡器可以优雅地处理这个问题。只需向web服务器池添加更多服务器，负载平衡器就会自动开始向它们发送请求。 现在网络层看起来不错，数据层呢？当前设计有一个数据库，因此它不支持故障转移和冗余。数据库复制(Database replication)是解决这些问题的常见技术。让我们来看看。 数据库复制引自维基百科：“数据库复制可以在许多数据库管理系统中使用，通常原始（主）和副本（从）之间具有主/从关系”[3]。 master数据库通常只支持写操作,slave数据库从主数据库获取数据副本，slave只支持读取操作。所有数据修改命令（如insert、delete或update）都必须发送到主数据库。大多数应用程序读操作的比例远大于写， 因此，系统中从数据库的数量通常大于主数据库的数量。图1-5显示了一个master数据库和多个slave数据库。 数据库复制的优势： 更好的性能：在主-从模式下，所有写入和更新都发生在主节点上，读取操作分布在从节点上。这种模式提高了性能，支持并行处理更多的查询 可靠性：如果您的一台数据库服务器被不可抗力因素破坏，例如地震、台风，数据仍会保留。不必担心数据丢失，因为数据被跨区域、多点备份 高可用性：通过在不同的位置备份数据，当一台数据库离线了，网站仍然可用 在上一节中，我们讨论了负载均衡器如何帮助提高系统可用性。我们在这里问同样的问题：如果其中一个数据库离线怎么办？图1-5中讨论的建筑设计可以处理这种情况： 如果只有一个slave数据库可用，并且它处于离线状态，则读取操作将临时指向主数据库。故障被发现后，新的从数据库将取代旧的。如果有多个从数据库可用，读取操作将重定向到其他正常的从数据库。新的数据库服务器将取代旧的数据库服务器 如果master数据库离线，slave数据库将升级为新的master数据库。所有数据库操作将临时在新的主数据库上执行。新的slave数据库将立即取代旧的数据库进行数据复制。在生产项目中，升级一个新的主数据库更加复杂，因为从数据库中的数据可能不是最新的。丢失的数据需要通过运行数据恢复脚本进行更新。虽然其他一些复制方法，如多台master主机和循环复制，但会使配置更加复杂, 这里超出了讨论的范围。感兴趣的读者可以参考这些文章[4][5]。 图1-6显示了添加负载平衡器和数据库复制后的系统设计。 让我们看看设计：： 用户从DNS获取负载均衡器的IP地址。 用户将负载均衡器与此IP地址连接。 HTTP请求被路由到服务器1或服务器2。 Web服务器从从属数据库读取用户数据。 Web服务器将任何数据修改操作路由到主数据库。这包括写入、更新和删除操作。 现在，您对网络和数据层有了扎实的了解，是时候提高负载/响应时间了。这可以通过添加缓存层并将静态内容（JavaScript/CSS/图像/视频文件）转移到内容交付网络（CDN）来完成。 缓存缓存是一个临时存储区域，将昂贵响应或经常访问的数据的结果存储在内存中，以便更快地收到后续请求。如图1-6所示，每次加载新网页时，都会执行一个或多个数据库调用来获取数据。重复调用数据库会对应用程序性能产生很大影响。缓存可以缓解这个问题。 缓存层缓存层是一个临时数据存储层，比数据库快得多。拥有单独的缓存层的好处包括更好的系统性能，减少数据库工作负载的能力，以及独立扩展缓存层的能力。图1-7显示了缓存服务器的可能设置： 收到请求后，Web服务器首先检查缓存是否有可用的响应。如果有，它会将数据发回给客户端。如果没有，它会查询数据库，将响应存储在缓存中，并将其发送回客户端。这种缓存策略称为通读缓存。根据数据类型、大小和访问模式，可以使用其他缓存策略。之前的一项研究解释了不同的缓存策略是如何工作的[6]。 与缓存服务器交互很简单，因为大多数缓存服务器为常见编程语言提供API。以下代码片段显示了典型的Memcached API： 使用缓存的注意事项以下是使用缓存系统的一些注意事项： 决定何时使用缓存。当数据被频繁读取但很少修改时，请考虑使用缓存。由于缓存数据存储在易失性内存中，因此缓存服务器不是持久数据的理想选择。例如，如果缓存服务器重新启动，内存中的所有数据都会丢失。因此，重要数据应保存在持久数据存储中。 到期政策。实施到期政策是一种良好做法。一旦缓存数据过期，它就会从缓存中删除。当没有过期策略时，缓存的数据将永久存储在内存中。建议不要让到期日期太短，因为这会导致系统过于频繁地从数据库中重新加载数据。同时，最好不要让过期日期太长，因为数据可能会变得过时。 一致性：这涉及保持数据存储和缓存同步。不一致可能会发生，因为数据存储和缓存上的数据修改操作不在单个事务中。当跨多个区域进行扩展时，保持数据存储和缓存之间的一致性具有挑战性。有关更多详细信息，请参阅Facebook[7]发布的题为“在Facebook上扩展Memcache”的论文。 缓解故障：单个缓存服务器代表潜在的单点故障（SPOF），在维基百科中定义如下：“单点故障（SPOF）是系统的一部分，如果失败，将阻止整个系统工作”[8]。因此，建议跨不同数据中心的多个缓存服务器，以避免SPOF。另一种推荐的方法是以一定百分比过度配置所需的内存。随着内存使用量的增加，这提供了一个缓冲区。 驱逐政策：一旦缓存已满，任何向缓存添加项目的请求都可能导致现有项目被删除。这被称为缓存驱逐。最近使用最少（LRU）是最受欢迎的缓存驱逐政策。可以采用其他驱逐政策，如最不常用（LFU）或先到先出（FIFO），以满足不同的用例。 内容交付网络（CDN）CDN是一个地理上分散的服务器网络，用于提供静态内容。CDN服务器缓存静态内容，如图像、视频、CSS、JavaScript文件等。 动态内容缓存是一个相对较新的概念，超出了本书的范围。它允许缓存基于请求路径、查询字符串、cookie和请求标头的HTML页面。有关此的更多信息，请参阅参考材料[9]中提到的文章。这本书重点介绍如何使用CDN缓存静态内容。 以下是CDN在高层的工作方式：当用户访问网站时，最靠近用户的CDN服务器将提供静态内容。直觉上，来自CDN服务器的用户越大，网站加载速度就越慢。例如，如果CDN服务器在旧金山，洛杉矶的用户将比欧洲用户更快地获得内容。图1-9是一个很好的例子，显示了CDN如何改善加载时间。 图1-10展示了CDN工作流程。 1.用户A尝试使用图像URL获取image.png。URL的域由CDN提供商提供。以下两个图像URL是用于演示亚马逊和Akamai CDN上图像URL的示例： Https://mysite.cloudfront.net/logo.jpg Https://mysite.akamai.com/image-manager/img/logo.jpg 2.如果CDN服务器在缓存中没有image.png，CDN服务器从源请求文件，源可以是Web服务器或像Amazon S3这样的在线存储。 3.源将image.png返回给CDN服务器，其中包括可选的HTTP头Time-to-Live（TTL），该标题描述了图像的缓存时间。 4.CDN缓存图像并将其返回给用户A。图像在CDN中保持缓存，直到TTL过期。 5.用户B发送请求以获取相同的图像。 6.只要TTL没有过期，图像就会从缓存中返回。 使用CDN的注意事项 成本：CDN由第三方提供商运行，并向您收取进出CDN的数据传输费用。缓存不经常使用的资产没有显著的好处，因此您应该考虑将它们移出CDN。 设置适当的缓存到期：对于时间敏感的内容，设置缓存到期时间很重要。缓存到期时间不应太长，也不应太短。如果太长，内容可能不再新鲜。如果太短，可能会导致内容从原始服务器重复重新加载到CDN。 CDN回退：您应该考虑您的网站/应用程序如何应对CDN故障。如果CDN暂时中断，客户端应该能够检测到问题并从源请求资源。 文件无效：您可以通过执行以下操作之一，在文件过期前将其从CDN中删除： 使用CDN供应商提供的API使CDN对象无效。 使用对象版本控制来服务对象的不同版本。要对对象进行版本，您可以向URL添加参数，例如版本号。例如，版本号2被添加到查询字符串中：image.png?V=2。 图1-11显示了添加CDN和缓存后的设计。 1.静态资产（JS、CSS、图像等）不再由Web服务器提供服务。为了获得更好的性能，它们是从CDN中获取的。 2.通过缓存数据来减轻数据库负载。 无状态网络层（Stateless web tier）现在考虑水平扩展Web层，为此，我们需要将state 数据移出web层（例如用户session数据）。一个好的做法是将session数据存储在持久性存储中，如关系数据库或NoSQL。集群中的每个web服务器都可以访问数据库中的state数据。这被称为无状态web层。 有状态架构(stateful)有状态server和无状态server有以下区别： 在多个请求中，有状态server会记住client数据（状态），无状态server不做任何记录。 图1-12展示了有状态（stateful）架构： 在图1-12中，UserA的session数据和个人资料存储在server1中。要对用户A进行身份验证，必须将HTTP请求路由到server1。如果请求被发送到server2等其他服务器，身份验证将失败，因为server2不包含UserA的会话数据。同样，来自user B的所有HTTP请求都必须路由到server2；来自UserC的所有请求都必须发送到server3。 这样会产生问题：来自同一client的每个请求都必须路由到同一server。虽然这可以通过大多数负载平衡器中的粘性 session来实现[10]；但这会这增加开销。使用这种方法，添加或删除服务器要困难得多，处理服务器故障也很困难。 无状态架构(stateless)图1-13显示了无状态架构。 在这种无状态架构中，用户的HTTP请求可以发送到任何web服务器。web服务器从共享数据库中获取状态数据。状态数据存储在共享数据存储中，不在web服务器内，使得系统更简单、更健壮且可扩展。 图1-14展示了无状态web层的架构设计： 在图1-14中，我们将session数据移出web层，并将其存储在持久数据存储中。共享数据存储可以是关系数据库、Memcached/Redis、NoSQL等。推荐使用NoSQL数据存，因为其易于扩展。自动缩放(Autoscaling)意味着可以根据流量负载自动添加或删除web服务器。从web服务器中删除状态数据后，可以根据流量负载添加或删除服务器，从而轻松实现web层的自动扩展。 当网站发展迅速，在国际上吸引了大量用户。为了在世界范围内提升可用性和更好的用户体验，支持多数据中心至关重要。 数据中心（Data centers）图1-15显示了带有两个数据中心的架构设计。常规操作中，用户被路由到最近的数据中心，分配到美国东部和美国西部的流量分别为x%和（100–x%）。geoDNS可以提供这样的域名解析服务，它基于用户的地理位置将域名解析为不同IP地址。 如果数据中心出现任何重大故障，我们会将所有流量转移到另外健康的数据中心。在图1-16中，ata center 2 (US-West）处于离线状态，100%的流量路由到data center 1 (US-East). 要实现多数据中心配置，必须解决几个技术难题： 流量重定向：需要有效的工具将流量引导到正确的数据中心。根据用户所在的位置，GeoDNS可用于将流量引导至最近的数据中心 数据同步：来自不同地区的用户可以使用不同的本地数据库或缓存。在故障转移情况下，流量可能会被路由到无用户数据的数据中心。一种常见的策略是跨多个数据中心复制数据。之前的一项研究显示了Netflix如何实现异步多数据中心备份[11]。 测试和部署：使用多数据中心设置，在不同位置测试网站/应用程序非常重要。自动化部署工具对于保证所有数据中心的服务一致性至关重要[11]。 为了进一步扩展我们的系统，我们需要解耦系统的不同组件，以便它们可以独立地进行扩展。消息队列被很多实际分布式系用来解决解耦问题。 消息队列（Message Queue）消息队列是存储在内存中的持久组件，支持异步通信。它充当缓冲区并分发异步请求。消息队列的基本架构很简单。输入服务（称为生产者/发布者）创建消息，并将其发布到消息队列。其他服务或服务器（称为使用者/订阅者）连接到队列，并执行消息定义的操作。模型如图1-17所示 解耦使得消息队列在构建可扩展、可靠的应用时更受到青睐。通过使用消息队列，当消费者无法处理消息时，生产者依然可以向队列发布消息；生产者不可用时，消费者也可以从队列中读取消息。 考虑下面情况：应用程序支持照片定制，包括裁剪、锐化、模糊等。这些定制任务需要一定时间来完成。在图1-18中，web服务器将照片处理任务发布到消息队列。照片处理worker从消息队列中提取任务，并异步执行照片自定义任务。生产者和消费者可以独立扩展。当队列变大时，会添加更多的er以减少处理时间。但是，如果队列大部分时间都是空的，则可以减少worker的数量。 logging、指标(metric)、自动化当在少量的服务器上运行的小型网站时，采用log日志、metric和自动化支持是规范的做法，但不是必要的。然而，现在你的网站已经成长为一家大型企业，对这些工具的使用是必不可少的。 logging：监控错误日志很重要，因为它有助于识别系统中的错误和问题。您可以在每个服务器级别监视错误日志，或者使用工具将它们聚合到一个集中的服务中，以便于搜索和查看。 指标：收集不同类型的指标有助于我们获得业务洞察力，并了解系统的健康状态。以下一些指标很有用： 主机级指标：CPU、内存、磁盘I/O等。 聚合级指标：例如，整个数据库层、缓存层等的性能。 关键业务指标：日常活跃用户、保留量、收入等 自动化：当一个系统变得庞大复杂时，我们需要构建或利用自动化工具来提高生产力。持续集成是一种很好的做法，在这种做法中，每个代码签入都通过自动化进行验证，从而允许团队尽早发现问题。此外，自动化构建、测试、部署程序等，可以显著提高开发人员的生产率。 添加了消息队列和不同的工具的架构设计图1-19显示了更新后的设计。由于空间限制，图中只显示了一个数据中心。1.该设计包括一个消息队列，有助于使系统解耦和故障恢复。 2.包括日志记录、监控、metric和自动化工具 随着数据规模不断增长，数据层也会过载，所以需要扩展数据层 数据库扩展两种方式扩展：垂直扩展和水平扩展 垂直扩展垂直扩展也称为向上扩展，是指通过对现有机器的性能（进行扩展。CPU、RAM、磁盘等）。有一些性能很强大的数据库服务器。根据Amazon关系数据库服务（RDS）[12]，可支持具有24 TB RAM的数据库服务器。这种强大的数据库服务器可以存储和处理大量数据。例如， 在2013年每月有1000多万独立访客，但它只有一个主数据库[13]。然而，垂直扩展也有一些严重的缺点： 您可以向数据库服务器添加更多CPU、RAM等，但存在硬件限制。如果用户群很大，单台服务器是不够的 单点故障风险更大 垂直扩展的总体成本很高。性能强大的服务器要昂贵得多。水平缩放水平缩放也称为分片，是添加更多服务器的实践。图1-20比较了垂直缩放和水平缩放。 分片（sharding）将大型数据库分成更小、更易于管理的部分，称为分片。每个分片共享相同的模式，尽管每个分片上的实际数据对该分片是唯一的。 图1-21显示了分片数据库的示例。根据用户ID将数据分配给不同数据库服务器。访问数据时，使用哈希函数来查找相应的分片。在我们的示例中，使用user_id%4作为哈希函数。如果取余结果等于0，则使用分片0存储和获取数据。如果结果等于1，则使用分片1。同样的逻辑也适用于其他分片。 图1-22显示了分片数据库中的用户表。 在执行分片(sharding)策略时最重要因素是选择分片密钥(sharding key)。sharding key, 又称为partition key）由一个或多个列组成，这些列决定数据的分布方式。如图1-22所示，“用户id”是sharding key。通过sharding key，路由到正确的数据库，对数据进行修改和检索数据。在选择sharding key时，最重要的标准之一是选择一个可以均匀分布数据的列。 sharding是一种很好的扩展数据库的技术，但它远不是一个完美的解决方案。它给系统带来了新的挑战： 重新分片(resharding )数据： 1）单个碎片由于快速增长而无法保存更多数据时，需要重新sharding数据。2） 由于数据分布不均，某些碎片(shard)可能会比其他shard空间被更快使用完。当某个shard空间耗尽时，需要resharding 功能并移动数据。第5章讨论的一致性哈希可以解决这个问题。 名人问题: 这也被称为热点key问题。对特定shard的过度访问可能会导致服务器过载。想象一下，凯蒂·佩里（Katy Perry）、贾斯汀·比伯（Justin Bieber）和Lady Gaga的数据在同一块碎片上。对于社交应用程序，该碎片将被读取操作淹没。为了解决这个问题，需要为每个名人分配一个碎片。每个shard甚至可能需要进一步的分区。 join和反范式： 一旦数据库在多个服务器上被切分，就很难跨数据库执行join操作。常见的解决方法是对数据库进行反范式化，以便在单个表中执行查询。 在图 1-23 中，我们对数据库进行分片操作，以支持快速增长的数据流量。 同时，非关系功能的数据被存入 NoSQL ，以减少数据库负载。 这是一篇涵盖许多 NoSQL 用例的文章[14]。 百万及百万以上的用户系统的扩展是一个迭代的过程。重复我们在本章学到的知识，让我们走得更远。当用户数达到百万以上时，需要更多细微的调整和新的策略，例如，将系统解耦到更小的服务。本章所学的将为后面的挑战打好基础， 本章主要讲，如何扩展系统以支持数百万用户： 保持web层无状态 在每一层构建冗余 尽可能多地缓存数据 支持多个数据中心 在CDN中托管静态文件 通过分片扩展数据层 将每层分为独立的服务 为系统添加监控并使用自动化工具 参考文献[1] Hypertext Transfer Protocol:  [2] Should you go Beyond Relational Databases?:  [3] Replication: (computing) [4] Multi-master replication:  [5] NDB Cluster Replication: Multi-Master and Circular Replication:  [6] Caching Strategies and How to Choose the Right One:  [7] R. Nishtala, “Facebook, Scaling Memcache at,” 10th USENIX Symposium on Networked Systems Design and Implementation (NSDI ’13). [8] Single point of failure:  [9] Amazon CloudFront Dynamic Content Delivery:  [10] Configure Sticky Sessions for Your Classic Load Balancer: ​ ​ [11] Active-Active for Multi-Regional Resiliency:​ ​ [12] Amazon EC2 High Memory Instances:​ ​ [13] What it takes to run Stack Overflow:​ ​ [14] What The Heck Are You Actually Using NoSQL For:​ "},{"title":"苹果电脑型号对应系统版本号对照表","date":"2023-05-05T07:06:31.000Z","url":"/2023/05/05/%E8%8B%B9%E6%9E%9C%E7%94%B5%E8%84%91%E5%9E%8B%E5%8F%B7%E5%AF%B9%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC%E5%8F%B7%E5%AF%B9%E7%85%A7%E8%A1%A8/","tags":[["mac","/tags/mac/"]],"categories":[[" ",""]],"content":" MacBook Pro电脑型号 发布日期 最低macOS版本 最高macOS版本 建议macOS版本 备注 MacBook Pro 14/16寸 2023年 2023年01月 13.1.0 目前最新版本 目前最新版本 Apple M2 Pro/Max芯片 MacBook Pro 13/16寸 2022年 2022年06月 12.4.0 目前最新版本 目前最新版本 Apple M2芯片 MacBook Pro 14寸 2021年 2021年10月 11.6.1 目前最新版本 目前最新版本 Apple M1 Pro/Max芯片 MacBook Pro 13寸 2020年 2020年11月 11.0.1 目前最新版本 目前最新版本 Apple M1芯片 MacBook Pro 13寸 2020年初 4端口 2020年05月 10.15.4 目前最新版本 目前最新版本 10.15.4-19E2269 MacBook Pro 13寸 2020年初 2端口 2020年05月 10.15.4 目前最新版本 目前最新版本 10.15.4-19E2269 MacBook Pro 16寸 2019年末 2019年11月 10.15.2 目前最新版本 目前最新版本 10.15.1 (19B2106) MacBook Pro 13寸 2019年中期 2端口 2019年7月 10.14.6 目前最新版本 目前最新版本 MacBook Pro 15寸 2019年中期 2019年5月 10.14.6 目前最新版本 目前最新版本 MacBook Pro 13寸 2019年中期 4端口 2019年5月 10.14.6 目前最新版本 目前最新版本 MacBook Pro 15寸 有触控条 2018年中期 2018年6月 10.13.6 目前最新版本 目前最新版本 最低要求 10.13.6 17G2208 MacBook Pro 13寸 有触控条 2018年中期 2018年6月 10.13.6 目前最新版本 目前最新版本 最低要求 10.13.6 17G2208 MacBook Pro 15寸 有触控条 2017年 2017年6月 10.12.6 目前最新版本 目前最新版本 MacBook Pro 13寸 有触控条 2017年 2017年6月 10.12.6 目前最新版本 目前最新版本 MacBook Pro 13寸 无触控条 2017年 2017年6月 10.12.6 目前最新版本 目前最新版本 MacBook Pro 15寸 2016年末 2016年11月 10.12.6 目前最新版本 目前最新版本 – MacBook Pro 13寸 2016年末 有触控条 2016年11月 10.12.6 目前最新版本 目前最新版本 – MacBook Pro 13寸 2016年末 无触控条 2016年10月 10.12.6 目前最新版本 目前最新版本 – MacBook Pro 15寸 2015年中 2015年5月 10.10.5 目前最新版本 目前最新版本 – MacBook Pro 13寸 2015年初 2015年3月 10.10.5 目前最新版本 目前最新版本 – MacBook Pro 13/15寸 2014年中 2014年7月 10.9.5 目前最新版本 目前最新版本 – MacBook Pro 13/15寸 2013年末 2013年10月 10.9.5 11.6.2 11.6.1 – MacBook Pro 13/15寸 2013年初 2013年2月 10.8.5 11.6.2 11.6.1 – MacBook Pro 13寸 Retina 2012年末 2012年10月 10.8.5 11.6.2 11.6.1 – MacBook Pro 13/15寸 2012年中 2012年6月 10.7.5 10.15.7 10.15.7 – MacBook Pro 13/15/17寸 2011年末 2011年10月 10.7.5 10.13.6 10.12.6 – MacBook Pro 13/15/17寸 2011年初 2011年2月 10.6.6 10.13.6 10.12.6 – MacBook Pro 13寸 2010年中 2010年4月 10.7.5 10.13.6 10.12.6 出厂附送的10.6.3也支持 MacBook Pro 15/17寸 2010年中 2010年4月 10.6.3 10.13.6 10.12.6 – MacBook Pro 13/15/17寸 2009年中 2009年6月 10.5.7 10.11.6 10.11.6 – MacBook Pro 17寸 2009年初 2009年1月 10.5.6 10.11.6 10.11.6 – MacBook Pro 15/17寸 2008年初/末 2008年10月 10.5.6 10.11.6 10.11.6 MacBook Pro 15/17寸 2.4/2.2 GHz 2007年6月 10.4.10 10.7.5 10.7.5 MacBook Pro 15/17寸 Core 2 Duo 2006年10月 10.4.10 10.7.5 10.7.5 MacBook Pro 15/17寸 镜面 2006年2/4月 10.4.10 10.7.5 10.7.5 MacBook Air电脑型号 发布日期 最低macOS版本 最高macOS版本 建议macOS版本 备注 MacBook Air 14寸 2022年 2022年06月 12.4.0 目前最新版本 目前最新版本 Apple M2芯片 MacBook Air 13寸 2020年 2020年11月 11.0.1 目前最新版本 目前最新版本 Apple M1芯片 MacBook Air 13寸 2020年初 2020年03月 10.15.3 目前最新版本 目前最新版本 MacBook Air 13寸 2019年中期 2019年7月9日 10.14.6 目前最新版本 目前最新版本 – MacBook Air 13寸 2018年 2018年10月 10.14.6 目前最新版本 目前最新版本 – MacBook Air 13寸 2017年 2017年6月 10.12.6 目前最新版本 目前最新版本 – MacBook Air 11/13寸 2015年初 2015年3月 10.10.5 目前最新版本 目前最新版本 – MacBook Air 11/13寸 2014年初 2014年4月 10.9.5 目前最新版本 目前最新版本 – MacBook Air 11/13寸 2013年中 2013年6月 10.8.5 11.6.2 11.6.1 – MacBook Air 11/13寸 2012年中 2012年6月 10.7.5 11.6.2 11.6.1 – MacBook Air 11/13寸 2011年中 2011年7月 10.7.5 10.13.6 10.12.6 – MacBook Air 11/13寸 2010年末 2010年10月 10.6.4 10.13.6 10.12.6 – MacBook Air 13寸 2009年中 2009年6月 10.5.6 10.11.6 10.11.6 – MacBook Air 13寸 2008年末 2008年11月 10.5.6 10.11.6 10.11.6 MacBook Air 13寸 2008年初 2008年11月 10.5.6 10.7.5 10.7.5 MacBook电脑型号 发布日期 最低macOS版本 最高macOS版本 建议macOS版本 备注 MacBook 12寸 2017年 2017年6月 10.12.6 目前最高版本 目前最高版本 – MacBook 12寸 2016初 2016年4月 10.11.6 目前最高版本 目前最高版本 – MacBook 12寸 2015初 2015年4月 10.10.5 目前最高版本 目前最高版本 – MacBook 13寸 2010中 2010年5月 10.6.3 10.13.6 10.12.6 – MacBook 13寸 2009末 2009年10月 10.6.3 10.13.6 10.12.6 – MacBook 13寸 2009初/中 2009年1月 10.5.6 10.11.6 10.11.6 – MacBook 13寸 2008末铝合金外壳 2008年10月 10.5.6 10.11.6 10.11.6 MacBook 13寸 2008末 (非铝合金外壳) 2008年10月 10.5.6 10.7.5 10.7.5 10.7.5最低要2G内存 MacBook 13寸 2008初 2008年2月 10.5.6 10.7.5 10.7.5 10.7.5最低要2G内存 MacBook 13寸 2007中/末 2007年5/10月 10.5.6 10.7.5 10.6.X 10.6.x最低要1G内存 MacBook 13寸 2006年末 2006年11月 10.4.8 10.7.5 10.7.5 10.7.5要求2G或以上的内存 MacBook 13寸 2006年初 2006年5月 10.4.8 10.7.5 10.6.X 10.6.x要求1G或以上的内存 iMac电脑型号 发布日期 最低macOS版本 最高macOS版本 建议macOS版本 备注 iMac 24寸 4.5K 2021年 2021年5月 11.3 目前最高版本 目前最高版本 M1芯片 iMac 27寸 5K 2020年 2020年8月 10.15.6(19G2005) 目前最高版本 目前最高版本 T2芯片 iMac 21.5寸 4K 2020年 2020年8月 10.14.6 目前最高版本 目前最高版本 对比2019款只更新了硬盘 iMac 27寸 5K 2019年 2019年3月 10.14.6 目前最高版本 目前最高版本 – iMac 21.5寸 4K 2019年 2019年3月 10.14.6 目前最高版本 目前最高版本 – iMac Pro 27寸 5K 2017年 2017年12月 10.13.6 目前最高版本 目前最高版本 – iMac 27寸 5K 2017年 2017年6月 10.12.6 目前最高版本 目前最高版本 – iMac 21.5寸 4K 2017年 2017年6月 10.12.6 目前最高版本 目前最高版本 – iMac 21.5寸 普通屏 2017年 2017年6月 10.12.6 目前最高版本 目前最高版本 – iMac 21.5/27寸 2015年末 2015年10月 10.11.6 目前最高版本 目前最高版本 – iMac 27寸 5K 2015年中 2015年5月 10.10.5 目前最高版本 目前最高版本 – iMac 27寸 5K 2014年末 2014年10月 10.10.5 目前最高版本 目前最高版本 – iMac 21.5寸 2014年中 2014年6月 10.9.5 目前最高版本 目前最高版本 – iMac 21.5/27寸 2013年末 2013年9月 10.8.5 11.6.2 11.6.1 – iMac 21.5/27寸 2012年末 2012年11/12月 10.8.5 11.6.2 11.6.1 – iMac 21.5寸 2011年末 2011年8月 10.7.5 10.13.6 10.12.6 – iMac 21.5/27寸 2011年中 2011年5月 10.6.6 10.13.6 10.12.6 仅支持随机附送的10.6.6 iMac 27寸 2010年中 2010年7月 10.6.3 10.13.6 10.12.6 – iMac 21.5寸 2010年中 2010年7月 10.6.3 10.13.6 10.12.6 – iMac 21.5/27寸 2009年末 2009年10/11月 10.6.3 10.13.6 10.12.6 – iMac 20寸 2009年中 2009年4月 10.5.6 10.11.6 10.11.6 – iMac 20/24寸 2009年初 2009年3月 10.5.6 10.11.6 10.11.6 – iMac 20/24寸 2008年初 2008年4月 10.5.6 10.11.6 10.11.6 – iMac 20/24寸 2007年中 2007年8月 10.4.10 10.11.6 10.11.6 – iMac 17/20/24寸 2006年末 2006年9月 10.4.7 10.7.5 10.7.5 – iMac 17 2006年初/中 2006年1/7月 10.4.6 10.7.5 10.7.5 – Mac Studio电脑型号 发布日期 最低macOS版本 最高macOS版本 建议macOS版本 备注 Mac Studio M1 2022年初 2022年3月 12.2.0 目前最高版本 目前最高版本 Apple M1 Max/Ultra芯片 Mac Mini电脑型号 发布日期 最低macOS版本 最高macOS版本 建议macOS版本 备注 Mac Mini 2023年初 2023年1月 13.1.0 目前最新版本 目前最新版本 Apple M2/Pro芯片 Mac Mini 2020年末 2020年11月 11.0.1 目前最新版本 目前最新版本 Apple M1芯片 Mac Mini 2020年初 2020年3月 10.14.6 目前最新版本 目前最新版本 只升级了硬盘 Mac Mini 2018年末 2018年10月 10.14.6 目前最新版本 目前最新版本 – Mac Mini 2014年末 2014年10月 10.10.5 目前最新版本 目前最新版本 – Mac Mini/Server 2012年末 2012年10月 10.8.5 11.6.2 11.6.1 – Mac Mini/Server 2011年中 2011年7月 10.7.5 10.13.6 10.13.6 – Mac Mini 2010年中 2010年6月 10.6.3 10.13.6 10.13.6 – Mac Mini 2009年末 2009年10月 10.6.3 10.11.6 10.11.6 – Mac Mini 2009年初 2009年3月 10.5.6 10.11.6 10.11.6 – Mac Mini 2007年中 2007年8月 10.4.10 10.7.5 10.7.5 – Mac Mini 2006年末 2006年9月 10.4.7 10.7.5 10.7.5 – Mac Mini 2006年初 2006年3月 10.4.5 10.7.5 10.7.5 – Mac Pro电脑型号 发布日期 最低macOS版本 最高macOS版本 建议macOS版本 备注 Mac Pro 2019年末 2019年12月 10.15.2 目前最新版本 目前最新版本 – Mac Pro 2013年末 2013年12月 10.9.5 11.6.2 11.6.1 – Mac Pro 2012年中 2012年6月 10.7.5 10.14.6 10.13.6 特别说明 Mac Pro 2010年中 2010年8月 10.6.4 10.14.6 10.13.6 特别说明 Mac Pro 2009年初 2009年3月 10.5.6 10.11.6 10.11.6 – Mac Pro 2008年初 2008年1月 10.5.6 10.11.6 10.11.6 Mac Pro 2006年中 2006年8月 10.4.7 10.7.5 10.7.5 – Xserve电脑型号 发布日期 最低macOS版本 最高macOS版本 建议macOS版本 备注 Xserve 2009年初 2009年4月 10.5.6 10.11.6 10.11.6 – Xserve 2008年初 2008年1月 10.5.1 10.7.5 10.7.5 – Xserve 2006年末 2006年11月 10.4.8 10.7.5 10.7.5 – "},{"title":"Xcode真机运行报错：Failed to prepare the device for development解决方法","date":"2023-04-28T02:25:17.000Z","url":"/2023/04/28/Xcode%E7%9C%9F%E6%9C%BA%E8%BF%90%E8%A1%8C%E6%8A%A5%E9%94%99%EF%BC%9AFailed-to-prepare-the-device-for-development%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","tags":[["iOS","/tags/iOS/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"]],"content":" 本文讲解了在Xcode不支持iOS系统版本时如何通过增加Xcode系统支持来解决问题。当出现报错“Failed to prepare the device for development. This operation can fail if the version of the OS on the device is incompatible with the installed version of Xcode. You may also need to restart your Mac and device in order to correctly detect compatibility.”时，首先尝试重启iOS设备，之后查看Xcode版本是否支持当前手机系统。如果不支持，可以通过进入iOSDeviceSupport项目（Gitee或Github）下载需要支持的系统文件，新建一个文件夹，然后将解压好的内容全部粘贴进去，最后再真机运行即可。 当遇到此报错Failed to prepare the device for development. This operation can fail if the version of the OS on the device is incompatible with the installed version of Xcode. You may also need to restart your Mac and device in order to correctly detect compatibility. 首先你应该做的是尝试重启你的iOS设备。 重启连不上之后可以查看一下你的Xcode版本是否支持你现在的手机系统。 增加Xcode系统支持进入 iOSDeviceSupport （或者Github在这里） 下载你需要支持的系统文件 然后再打开终端，输入 然后把解压的文件夹放进去 "},{"title":"通过Xcode对ipa进行重签名","date":"2023-04-28T02:07:39.000Z","url":"/2023/04/28/%E9%80%9A%E8%BF%87Xcode%E5%AF%B9ipa%E8%BF%9B%E8%A1%8C%E9%87%8D%E7%AD%BE%E5%90%8D/","tags":[["破解","/tags/%E7%A0%B4%E8%A7%A3/"],["ipa","/tags/ipa/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"]],"content":"1. 首先新建一个Xcode工程在工程目录下新建一个APP的文件夹 2.在工程中新增一个脚本运行 脚本如下 "},{"title":"网页在线工具汇总","date":"2023-04-27T09:15:00.000Z","url":"/2023/04/27/%E7%BD%91%E9%A1%B5%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB/","tags":[["工具","/tags/%E5%B7%A5%E5%85%B7/"]],"categories":[["工具","/categories/%E5%B7%A5%E5%85%B7/"]],"content":"常用在线工具 文件传输 在线听歌 看电影 今日热榜 上班摸鱼 免费图床 找电影 note.ms 匿名分享 文本配音 PDF 压缩 高清壁纸 链接提取 ocr 识别 pp 直连 加密解密 快速搜索 视频压缩 在线笔记 缩短网址 短视频解析 写简历 图片压缩 做 Logo 智能法律咨询 生活急救指南 快速定位资源：大佬点入、dalao.ru 工具合集 影视在线大全 音乐在线大全 短信接码网站 匿名分享服务 网盘加速方法 资源搜索引擎 图片无损放大 国内在线分享服务 图片压缩网站 在线抠图大全 免费文件存储 临时邮箱大全 免费图床大全 二维码生成 短地址汇总 ip 查询大全 蛙蛙在线工具箱 67 工具箱 云极客工具 独特工具箱 实用在线工具展开目录 在线格式转换 白描 ocr 加密格式音乐解锁 视频 AI 转换文本 网址汉字移除 表格转换工具 在线 pdf 工具箱 音乐剪辑 跑马灯 视频转 gif 直播源转换 图片转换器 在线图标制作 图片编辑 支付宝到账语音 冷熊简历 域名查询 m3u8 下载 相似词查询 种子磁立互转 "},{"title":"iPhone尺寸大全（包含iPhone14系列）","date":"2023-04-24T08:34:18.000Z","url":"/2023/04/24/iPhone%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%85%A8%EF%BC%88%E5%8C%85%E5%90%ABiPhone14%E7%B3%BB%E5%88%97%EF%BC%89/","tags":[["iOS","/tags/iOS/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"]],"content":" 机型 屏幕尺寸（英寸） 分辨率（pt） 像素（pixel） 图片后缀 iPhone4/4s 3.5（326ppi） 320x480 640x960 @2x iPhone5/5c/5s/SE 4 （326ppi） 320x568 640x1136 @2x iPhone6/6s/7/8 4.7 （326ppi） 375x667 750x1334 @2x iPhone6/6s/7/8 Plus 5.5 （401ppi） 414x736 1242x2208 @3x iPhoneX/iPhoneXS/11Pro 5.8（458ppi） 375x812 （安全区域: (44, 0, 0, 34)） 1125x2436 @3x iPhoneXR/11 6.1（326ppi） 414x896 （安全区域: (48, 0, 0, 34)） 828x1792 @2x iPhoneXSMax/11ProMax 6.5（458ppi） 414x896（安全区域: (47, 0, 0, 34)） 1242x2688 @3x iPhone12mini（&gt;=iOS14） iPhone13mini（&gt;=iOS15） 5.4（476ppi） 360x780 （安全区域: (47, 0, 0, 34)） 1080x2340 @3x iPhone12/12Pro iPhone13/13Pro 6.1（460ppi） 390x844 （安全区域: (47, 0, 0, 34)） 1170x2532 @3x iPhone12/13ProMax 6.7（458ppi） 428x926 （安全区域: (47, 0, 0, 34)） 1284x2778 @3x iPhone14 （&gt;=iOS16） 6.1（460ppi） 390x844 （安全区域: (47, 0, 0, 34)） 1170x2532 @3x iPhone14 Plus 6.7（458ppi） 428x926 （安全区域: (47, 0, 0, 34)） 1284x2778 @3x iPhone14 Pro 6.1（460ppi） 393x852（安全区域: (59, 0, 0, 34)） 适配灵动岛高度 54的状态栏高度 59的安全区域高度 1179x2556 @3x iPhone14 Pro Max 6.7（460ppi） 430x932（安全区域: (59, 0, 0, 34)） 适配灵动岛高度 54的状态栏高度 59的安全区域高度 1290x2796 @3x "},{"title":"react native 配置react-native-web","date":"2022-12-09T02:31:10.000Z","url":"/2022/12/09/react-native-%E9%85%8D%E7%BD%AEreact-native-web/","tags":[["react-native","/tags/react-native/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"]],"content":"react native 配置react-native-web1.安装依赖 webpack相关和 babel-plugin-react-native-web 2.根目录新建 web/webpack.config.js 3.根目录新建 web/index.html 文件 4.根目录新建 index.web.js 文件 5.配置 package.json 启动命令 6.现在可以启动项目了 "},{"title":"搞懂DNS","date":"2022-02-16T07:55:35.000Z","url":"/2022/02/16/%E6%90%9E%E6%87%82DNS/","tags":[["网络","/tags/%E7%BD%91%E7%BB%9C/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"]],"content":"什么是DNSDNS 即域名系统，全称是 Domain Name System。当我们在浏览器输入一个 URL 地址时，浏览器要向这个 URL 的主机名对应的服务器发送请求，就得知道服务器的 IP，对于浏览器来说，DNS 的作用就是将主机名转换成 IP 地址。下面是摘自《计算机网络：自顶向下方法》的概念： DNS 是： 一个由分层的 DNS 服务器实现的分布式数据库 一个使得主机能够查询分布式数据库的应用层协议 也就是，DNS 是一个应用层协议，我们发送一个请求，其中包含我们要查询的主机名，它就会给我们返回这个主机名对应的 IP； 其次，DNS是一个分布式数据库，整个DNS系统由分散在世界各地的很多台DNS服务器组成，每台DNS服务器上都保存了一些数据，这些数据可以让我们最终查到主机名对应的IP。 所以 DNS 的查询过程，说白了，就是去向这些 DNS 服务器询问，你知道这个主机名的 IP 是多少吗，不知道？那你知道去哪台 DNS 服务器上可以查到吗？直到查到我想要的 IP 为止。 分布式、层次数据库什么是分布式？这个世界上没有一台 DNS 服务器拥有因特网上所有主机的映射，每台 DNS 只负责部分映射。 什么是层次？DNS 服务器有 3 种类型：根 DNS 服务器、顶级域（Top-Level Domain, TLD）DNS 服务器和权威 DNS 服务器。它们的层次结构如下图所示： 图片来源：《计算机网络：自顶向下方法》 根 DNS 服务器 首先我们要明确根域名是什么，比如 www.baidu.com，有些同学可能会误以为 com 就是根域名，其实 com 是顶级域名，www.baidu.com 的完整写法是 www.baidu.com.，最后的这个 . 就是根域名。 根 DNS 服务器的作用是什么呢？就是管理它的下一级，也就是顶级域 DNS 服务器。通过询问根 DNS 服务器，我们可以知道一个主机名对应的顶级域 DNS 服务器的 IP 是多少，从而继续向顶级域 DNS 服务器发起查询请求。 顶级域 DNS 服务器 除了前面提到的 com 是顶级域名，常见的顶级域名还有 cn、org、edu 等。顶级域 DNS 服务器，也就是 TLD，提供了它的下一级，也就是权威 DNS 服务器的 IP 地址。 权威 DNS 服务器 权威 DNS 服务器可以返回主机 - IP 的最终映射。 关于这几个层次的服务器之间是怎么交互的，接下来我们会讲到 DNS 具体的查询过程，结合查询过程，大家就不难理解它们之间的关系了。 本地DNS服务器之前对 DNS 有过了解的同学可能会发现，上一节的 DNS 层次结构，为什么没有提到本地 DNS 服务器？因为严格来说，本地 DNS 服务器并不属于 DNS 的层次结构，但它对 DNS 层次结构是至关重要的。那什么是本地 DNS 服务器呢？ 每个 ISP 都有一台本地 DNS 服务器，比如一个居民区的 ISP、一个大学的 ISP、一个机构的 ISP，都有一台或多台本地 DNS 服务器。当主机发出 DNS 请求时，该请求被发往本地 DNS 服务器，本地 DNS 服务器起着代理的作用，并负责将该请求转发到 DNS 服务器层次结构中。 接下来就让我们通过一个简单的例子，看看 DNS 的查询过程是怎样的，看看客户端、本地 DNS 服务器、DNS 服务器层次结构之间是如何交互的。 递归查询、迭代查询如下图，假设主机 m.n.com 想要获取主机 a.b.com 的 IP 地址，会经过以下几个步骤： 首先，主机 m.n.com 向它的本地 DNS 服务器发送一个 DNS 查询报文，其中包含期待被转换的主机名 a.b.com； 本地 DNS 服务器将该报文转发到根 DNS 服务器； 该根 DNS 服务器注意到 com 前缀，便向本地 DNS 服务器返回 com 对应的顶级域 DNS 服务器（TLD）的 IP 地址列表。 ​ 意思就是，我不知道 a.b.com 的 IP，不过这些 TLD 服务器可能知道，你去问他们吧； 本地 DNS 服务器则向其中一台 TLD 服务器发送查询报文； 该 TLD 服务器注意到 b.com 前缀，便向本地 DNS 服务器返回权威 DNS 服务器的 IP 地址。 ​ 意思就是，我不知道 a.b.com 的 IP，不过这些权威服务器可能知道，你去问他们吧； 本地 DNS 服务器又向其中一台权威服务器发送查询报文； 终于，该权威服务器返回了 a.b.com 的 IP 地址； 本地 DNS 服务器将 a.b.com 跟 IP 地址的映射返回给主机 m.n.com，m.n.com 就可以用该 IP 向 a.b.com 发送请求啦。 主机 m.n.com 向本地 DNS 服务器 dns.n.com 发出的查询就是递归查询，这个查询是主机 m.n.com 以自己的名义向本地 DNS 服务器请求想要的 IP 映射，并且本地 DNS 服务器直接返回映射结果给到主机。 而后继的三个查询是迭代查询，包括本地 DNS 服务器向根 DNS 服务器发送查询请求、本地 DNS 服务器向 TLD 服务器发送查询请求、本地 DNS 服务器向权威 DNS 服务器发送查询请求，所有的请求都是由本地 DNS 服务器发出，所有的响应都是直接返回给本地 DNS 服务器。 那么问题来了，所有的 DNS 查询都必须遵循这种递归 + 迭代的模式吗？ 当然不是。 从理论上讲，任何 DNS 查询既可以是递归的，也可以是迭代的。下图的所有查询就都是递归的，不包含迭代。 那么，TLD 一定知道权威 DNS 服务器的 IP 地址吗？ 还真不一定，有时 TLD 只是知道中间的某个 DNS 服务器，再由这个中间 DNS 服务器去找到权威 DNS 服务器。这种时候，整个查询过程就需要更多的 DNS 报文。 DNS缓存为了让我们更快的拿到想要的 IP，DNS 广泛使用了缓存技术。DNS 缓存的原理非常简单，在一个 DNS 查询的过程中，当某一台 DNS 服务器接收到一个 DNS 应答（例如，包含某主机名到 IP 地址的映射）时，它就能够将映射缓存到本地，下次查询就可以直接用缓存里的内容。当然，缓存并不是永久的，每一条映射记录都有一个对应的生存时间，一旦过了生存时间，这条记录就应该从缓存移出。 事实上，有了缓存，大多数 DNS 查询都绕过了根 DNS 服务器，需要向根 DNS 服务器发起查询的请求很少。 参考："},{"title":"iOS 如何让编译器跳过不支持模拟器的.a文件","date":"2022-01-18T06:27:55.000Z","url":"/2022/01/18/iOS-%E5%A6%82%E4%BD%95%E8%AE%A9%E7%BC%96%E8%AF%91%E5%99%A8%E8%B7%B3%E8%BF%87%E4%B8%8D%E6%94%AF%E6%8C%81%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%9A%84-a%E6%96%87%E4%BB%B6/","tags":[["iOS","/tags/iOS/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"]],"content":" 我们在开发中经常会接入第三方的静态库.a 文件，有的静态库文件支持的架构比较多 x86、arm64、arm7s、arm7这样我们编译的时候不会出错。但是支持的架构越多最后生成的ipa包就越大，比如x86的架构，生产环境根本用不到，许多第三方给出的.a文件就不会包含这个架构。这样就只能真机运行测试了。那我们想用模拟器测试怎么办呢？下面给出两种解决办法。 规避法 补全法 新建一个同名的工程 把第三方库的头文件都拷贝进去 把所有借口都使用假函数实现一遍，然后编译出模拟器版本 把第三方的静态库lib1.a和我们编译出来的lib2.a合并lipo -create lib1.a lib2.a -output libXATA.a "},{"title":"react native ios 滚动条位置异常","date":"2022-01-13T02:14:38.000Z","url":"/2022/01/13/react-native-ios-%E6%BB%9A%E5%8A%A8%E6%9D%A1%E4%BD%8D%E7%BD%AE%E5%BC%82%E5%B8%B8/","tags":[["react-native","/tags/react-native/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"]],"content":" React native ScrollView FlatList 滚动条位置异常、错位 解决方法 ScrollView 增加属性 在根目录 index.js 中添加 参考 "},{"title":"图床工具PicGo","date":"2022-01-05T07:26:09.000Z","url":"/2022/01/05/%E5%9B%BE%E5%BA%8A%E5%B7%A5%E5%85%B7PicGo/","tags":[["工具","/tags/%E5%B7%A5%E5%85%B7/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"]],"content":" 使用 Picgo+Github 搭建个人图床，为本地图片添加外部链接。 1. 创建 GitHub 仓库 注意事项：仓库类型要选择 public，否则访问不到图片 2.获取 token 创建完成后进入，选择右上角的 Settings 选择 Developer settings 3.选择 Personal access tokens，然后点击 Generate new token 填写一下 Note，过期时间选择无期限，并勾选 repo 即可，拉到页面最下方确认提交 创建完成后，即可看到 token。这个值一定要保存下来，因为只显示一次。 3. PicGo 设置1.下载 Picgo，选择你所需的版本 配置 GitHub 图床 仓库名、分支、token 配置好后，就能上传图片了。 4.搭配 CDN 使用 使用 GitHub 仓库作为图床，存在的问题是国内访问 github 的速度很慢，可以利用 jsDelivr CDN 来加速访问。jsDelivr 是一个免费开源的 CDN 解决方案，该平台是首个打通中国大陆与海外的免费 CDN 服务，拥有中国政府颁发的 ICP 许可证，无须担心中国防火墙问题而影响使用。使用 jsDelivr 加速访问，需要将自定义域名设置为用户名/图床仓库名/。 加上 cdn 后图片访问速度飞快。 测试：   失效了 改成 [github用户名]/[仓库名]@master/ 5.Typora 配置图床Typora 是最好用的 Markdown 编辑器，还可以搭配图床一起使用，非常 nice ～ PicGO 设置 Server Typora 设置 右键上传就行了。 "},{"title":"React Native 搭配 MobX 使用心得","date":"2021-09-09T02:56:39.000Z","url":"/2021/09/09/React-Native-%E6%90%AD%E9%85%8D-MobX-%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/","tags":[["react-native","/tags/react-native/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"]],"content":"React Native 使用 MobXMobX 是一个用于状态管理的Javascript库，它通过运用透明的函数式响应编程（Transparent Functional Reactive Programming，TFRP）使状态管理变得简单和可扩展，与React Native一起使用效果很好。 安装 Mobx 和 Mobx-reactMobx 是主要的库，而 mobx-react 具有用于 react 的 mobx 绑定。使用以下命令安装 Mobx 和 Mobx-react： 启用 Mobx 装饰器语法你也可以在没有装饰器语法的情况下使用 Mobx，但是使用装饰器可以简化代码，所以让我们启用它。 使用以下命令为装饰器安装 babel 插件： 并在 .babelrc文件中启用（注意，插件的顺序很重要）： 如何使用React上下文设置 Mobx让我们看看如何使用 react 和 react 上下文来设置 Mobx。 什么是react上下文？Context 提供了一种通过组件树传递数据的方法，而无需在每个级别手动向下传递 props。简单来说，React 上下文用于将一些数据存储在一个地方并在整个应用程序中使用它。每次修改上下文中的数据时，组件也会重新渲染。如果我们不使用上下文，那么我们将使用 props 手动传递数据。 从技术上讲，Mobx 和其他状态管理库也做同样的事情，但功能更多 设置一个基本的 Mobx store转到react native程序中的 src 文件夹，创建一个名为的文件夹services并创建一个名为的文件store.js 转到新创建的store.js文件并粘贴以下代码 store说明它是一个非常简单的存储，带有一个用于存储用户数据的用户对象、一个标题字符串、一些修改用户和标题的函数。@observable用于告诉 mobx 在修改 observable 属性时重新渲染组件。 @action是一个用于修改 observable 的函数。运行一个@actions也会触发autoRun如果您设置了其中任何一个，函数。 useStore 是我们的自定义钩子，用于在任何功能组件中使用 mobx 存储 withStore 是一个自定义 HOC（高阶组件），可以在任何类组件中使用 mobx 存储。 Mobx 使用转到App.js Home.js 功能组件使用 useStore 钩子"},{"title":"Android打包混淆出现java.lang.OutOfMemoryError: Java heap space","date":"2021-09-08T02:56:42.000Z","url":"/2021/09/08/Android%E6%89%93%E5%8C%85%E6%B7%B7%E6%B7%86%E5%87%BA%E7%8E%B0java-lang-OutOfMemoryError-Java-heap-space/","tags":[["Android","/tags/Android/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"]],"content":"配置 gradle.properties "},{"title":"系统签名app运行webview闪退问题","date":"2021-09-08T02:40:14.000Z","url":"/2021/09/08/%E7%B3%BB%E7%BB%9F%E7%AD%BE%E5%90%8Dapp%E8%BF%90%E8%A1%8Cwebview%E9%97%AA%E9%80%80%E9%97%AE%E9%A2%98/","tags":[["Android","/tags/Android/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"]],"content":" 开发定制Android系统应用时，系统签名后app闪退 java.lang.UnsupportedOperationException: For security reasons, WebView is not allowed in privileged processes "},{"title":"iOS 启动图尺寸适配","date":"2021-09-08T02:02:08.000Z","url":"/2021/09/08/iOS-%E5%90%AF%E5%8A%A8%E5%9B%BE%E5%B0%BA%E5%AF%B8%E9%80%82%E9%85%8D/","tags":[["Android","/tags/Android/"],["iOS","/tags/iOS/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"]],"content":" 在 iOS 开发早期，启动图适配，可以通过自定义 LaunchImage 通过设置多张图片来实现通过尺寸的适配，2020 年 4 月开始，所有使用 iOS 13 SDK 的 App 都必须提供 LaunchScreen 如果使用 LaunchScreen 一张图来适配所有尺寸的 iPhone 是一定不够的，不同程度的拉伸是不可避免的，解决办法 👇 方法一 LaunchScreen 中写自定义布局，把 LaunchScreen 当做一个页面，里面不仅仅可以放图片，也来用来放其他 view,这样，重新布局，来实现我们想要的启动页就很容易实现了，这种也是官方推荐的方法 方法二 仍然使用类似于 LaunchImage 的方法来实现，通过配置多张图片的方式，来达到多图适配的问题 在 Assets.xcasset 中新建一个 Image Set，并配置 拷贝如下 xml 内容到 Contents.json 中,并配置尺寸的图片到指定位置，设置只支持 iPhone 图片 3.设置好后，把图片加入到 LaunchImage 中，设置好约束，并把 contentMode 设置为Scale to Fill 删除 app 重新运行就能看到效果了。 记录一下 Android 启动图尺寸 "},{"title":"android 多个图表闪退","date":"2021-09-07T10:56:54.000Z","url":"/2021/09/07/android-%E5%A4%9A%E4%B8%AA%E5%9B%BE%E8%A1%A8%E9%97%AA%E9%80%80/","tags":[["react-native","/tags/react-native/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"]],"content":""},{"title":"Mac sourcetree自动添加ssh key","date":"2021-09-07T10:23:12.000Z","url":"/2021/09/07/Mac-sourcetree%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0ssh-key/","tags":[["SourceTree","/tags/SourceTree/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"]],"content":" config "},{"title":"yarn的常用命令","date":"2021-09-07T09:27:54.000Z","url":"/2021/09/07/yarn%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","tags":[["yarn","/tags/yarn/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"]],"content":"yarn 安装npm i yarn -g 查看版本yarn -v 新建 package.jsonyarn init 添加依赖通过 yarn add 添加依赖会更新 package.json 以及 yarn.lock 文件 1.开发环境 2.生产环境 3.全局 更新 移除 安装 运行脚本 显示包信息 列出所有依赖 管理 yarn 配置文件 缓存"},{"title":"iOS 开发解决dyld: Library not loaded: @rpath/xxx.framework/ ","date":"2021-09-07T09:06:20.000Z","url":"/2021/09/07/iOS-%E5%BC%80%E5%8F%91%E8%A7%A3%E5%86%B3dyld-Library-not-loaded-rpath-xxx-framework/","tags":[["iOS","/tags/iOS/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"]],"content":"最近使用百度人脸采集 sdk 时运行报错 解决办法 "},{"title":"react-native-webview禁止缩放和自适应高度","date":"2021-09-07T08:04:33.000Z","url":"/2021/09/07/react-native-webview%E7%A6%81%E6%AD%A2%E7%BC%A9%E6%94%BE%E5%92%8C%E8%87%AA%E9%80%82%E5%BA%94%E9%AB%98%E5%BA%A6/","tags":[["react-native","/tags/react-native/"]],"categories":[["技术","/categories/%E6%8A%80%E6%9C%AF/"]],"content":""},{"title":"friends","date":"2021-09-06T09:59:41.000Z","url":"/friends/index.html","categories":[[" ",""]]},{"title":"搜索","date":"2021-09-06T09:40:56.000Z","url":"/search/index.html","categories":[[" ",""]]},{"title":"tags","date":"2021-09-06T09:46:26.000Z","url":"/tags/index.html","categories":[[" ",""]]}]